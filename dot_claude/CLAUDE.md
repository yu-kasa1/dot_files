# 制約
## DO:
- 具体的な解決策を提示する
- 不明点は必ず確認する
- 変更を加える際は既存のコードスタイルを尊重する
## DON'T:
- 個人情報を要求する
- 確証のない情報を断定的に伝える
- 不明な点を勝手に補完して作業を進める

# 開発ルール
基本は各プロジェクトの`@docs/rules`に記載されている開発・コーディング規約を参照すること。
発見できない場合については各使用言語についてのベストプラクティスを実行すること。

# 開発方針
- **原則(仕様駆動開発)**: 仕様ドキュメントが「唯一の正しい情報源」です。基本的には仕様を理解してからコーディングしてください。
- **例外（バイブコーディング）**:
    - ユーザが仕様について触れず、バグ修正、リファクタリング、単純な変更(「〜メソッドを〜のように修正して」等)などを依頼した場合は、**仕様駆動開発に拘らずユーザーの指示を優先**してコード修正を行ってください。
    - この場合も、実装完了後は必ず `@code-reviewer` を呼び出して安全性を確認してください。
- 開発中機能の仕様ドキュメントは`@docs/plans`以下にあります。
- 過去に開発した機能の仕様ドキュメントは`@docs/pastplans`に保管されています。これらは仕様ドキュメント作成や実装の参考情報として利用してください。
- **仕様書・タスク書の配置ルール**:
    - 対象プロジェクトに `docs/` ディレクトリがある場合: `docs/plans/{YYYYMMDD}_{ブランチキー}/`
    - 対象プロジェクトに `docs/` ディレクトリがない場合: `~/.claude/plans/{プロジェクト名}/{YYYYMMDD}_{ブランチキー}/`
    - 命名規則（spec.md, tasks.md, tests.md等）はどちらの場合も同一とする。

# セッション運用ルール

## セッション分割
- よほど簡単な改修/修正でない限り、**設計フェーズと実装フェーズでセッションを分ける**こと。
  - 設計セッション: requirement-definer → spec-writer → task-writer → code-reviewer（設計レビュー）
  - 実装セッション: coder → test-writer → code-reviewer（コードレビュー） → doc-updater
- セッション間の引き継ぎは仕様書配置先（`docs/plans/` または `~/.claude/plans/{プロジェクト名}/`）配下のドキュメント（spec.md, tasks.md）が担う。

## 実装セッション開始時の必須手順
実装セッションを開始する際は、**作業に入る前に必ず以下のファイルを読み込む**こと:
1. `spec.md` — 仕様の全体像を把握する
2. `tasks.md` — タスク一覧と進捗状況を把握する
3. 対象プロジェクトの開発ルール（`@docs/rules`）

これにより、コンテキストが失われた状態からでも正しく作業を再開できる。

# サブエージェント連携

## db-analyzer
既存のデータベーススキーマを分析し、テーブル構造・リレーション情報を提供するエージェントです。
### 呼び出しルール
- **仕様策定時**: `@spec-writer`がDB設計を行う際に、既存スキーマ調査が必要な場合に呼び出します。
- **実装時**: `@coder`がマイグレーション/モデル実装を行う際に、既存テーブル構造の確認が必要な場合に呼び出します。
- **単独呼び出し**: DB構造を把握したい場合に直接呼び出すことも可能です。
- **対応フロー**:
  1. 調査目的・対象範囲を確認
  2. マイグレーション/モデルファイルを調査
  3. スキーマ分析レポートを作成
  4. ユーザー確認後、必要に応じて`@spec-writer`または`@coder`へ引き継ぎ
- **重要な制約**: Dockerコンテナ上のDBのみ参照可能（本番・ステージング環境は絶対禁止）

## requirement-definer
ユーザーの要望を整理し、仕様作成に必要な要件を定義するエージェントです。
### 呼び出しルール
- **新機能開発時**：ユーザーから新機能の開発依頼があった場合、まず`@requirement-definer`を呼び出して要件を整理してください。
- **対応フロー**：
  1. ユーザーの要望をヒアリング
  2. 出力先ディレクトリを確認
  3. 要件定義ドキュメントを作成
  4. ユーザー承認後、自動的に`@spec-writer`を呼び出し

## spec-writer
要件定義をもとに、実装可能な詳細仕様を作成するエージェントです。
### 呼び出しルール
- **要件定義完了後**：`@requirement-definer`の完了後に自動的に呼び出されます。
- **単独呼び出し**：既に要件が明確な場合は、直接`@spec-writer`を呼び出すことも可能です。
- **対応フロー**：
  1. 要件定義ドキュメントを読み込み
  2. 既存コードベースを調査
  3. 仕様ドキュメント（spec.md）を作成
  4. ユーザー承認後、自動的に`@task-writer`を呼び出し

## task-writer
仕様書をもとに、実装タスクを分解・整理し、実行可能なタスク一覧を作成するエージェントです。
### 呼び出しルール
- **仕様作成完了後**：`@spec-writer`の完了後に自動的に呼び出されます。
- **単独呼び出し**：既に仕様が明確な場合は、直接`@task-writer`を呼び出すことも可能です。
- **対応フロー**：
  1. 仕様ドキュメントを読み込み
  2. タスクを分解・整理
  3. タスク一覧ドキュメント（tasks.md）を作成
  4. ユーザー承認後、自動的に`@code-reviewer`を呼び出し

## test-writer
仕様書をもとにテストケースを抽出し、テストコードを作成するエージェントです。
### 呼び出しルール
- **タスク作成完了後**：テストファーストで進める場合に呼び出します。
- **実装完了後**：テストコードを作成する場合に呼び出します。
- **対応フロー**：
  1. 仕様ドキュメントを読み込み
  2. テストケースを抽出（正常系/異常系）※ユースケースの範囲内
  3. テストケース一覧（tests.md）を作成
  4. ユーザー承認後、テストコードを作成

## code-reviewer
コード品質・セキュリティ・開発ルール準拠をチェックし、修正案を提示するエージェントです。
### 呼び出しルール
- **タスク一覧作成完了後**：`@task-writer`の完了後に呼び出し、設計レビューを実施します。
- **仕様ドキュメント作成完了時**：設計レビューを実施します。
- **実装完了時**：コードレビューを実施します。
- **対応フロー**：修正案を提示し、**ユーザー確認後**に適用（勝手に適用せず、ワンクッション置くこと）

## coder
タスク一覧に基づき、仕様通りにコードを実装するエージェントです。
### 呼び出しルール
- **設計レビュー完了後**：`@code-reviewer`の設計レビュー完了後、ユーザーが実装を希望する場合に呼び出します。
- **単独呼び出し**：既にタスク一覧が存在する場合は、直接`@coder`を呼び出すことも可能です。
- **対応フロー**：
  1. タスク一覧（tasks.md）を読み込み
  2. 各タスクを順次実装
  3. **タスクごとにユーザー承認を待つ**
  4. 全タスク完了後、`@test-writer`または`@code-reviewer`を呼び出し
- **注意**：ユーザーが仕様設計のみを目的としている場合は、自動呼び出しをスキップします。

## doc-updater
コードの変更を検知し、仕様書を逆更新するエージェントです。
### 呼び出しルール
- **実装完了後**：仕様書との整合性を確認し、差分があれば更新提案します。
- **PRマージ前**：ドキュメントの整合性を最終チェックします。
- **対応フロー**：
  1. コード変更と仕様書を比較
  2. 差分・不整合を検出
  3. 仕様書の更新案を提示
  4. **ユーザー承認後**に更新を実施
